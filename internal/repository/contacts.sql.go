// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: contacts.sql

package repository

import (
	"context"
	"database/sql"
	"time"
)

const deleteContact = `-- name: DeleteContact :execresult
DELETE FROM contacts
WHERE uuid = ?
`

// hard delete contact
func (q *Queries) DeleteContact(ctx context.Context, uuid string) (sql.Result, error) {
	return q.exec(ctx, q.deleteContactStmt, deleteContact, uuid)
}

const insertContact = `-- name: InsertContact :one
INSERT INTO contacts (uuid, origin_uuid, recipient_uuid)
VALUES (
    ?, ?, ?
) RETURNING uuid, origin_uuid, recipient_uuid, created_at
`

type InsertContactParams struct {
	Uuid          string
	OriginUuid    string
	RecipientUuid string
}

// add contact to database
func (q *Queries) InsertContact(ctx context.Context, arg *InsertContactParams) (*Contact, error) {
	row := q.queryRow(ctx, q.insertContactStmt, insertContact, arg.Uuid, arg.OriginUuid, arg.RecipientUuid)
	var i Contact
	err := row.Scan(
		&i.Uuid,
		&i.OriginUuid,
		&i.RecipientUuid,
		&i.CreatedAt,
	)
	return &i, err
}

const readAllContacts = `-- name: ReadAllContacts :many
SELECT uuid, origin_uuid, recipient_uuid, created_at
FROM contacts
WHERE origin_uuid = ?
`

// retrieve all contacts assigned to specific user
func (q *Queries) ReadAllContacts(ctx context.Context, originUuid string) ([]*Contact, error) {
	rows, err := q.query(ctx, q.readAllContactsStmt, readAllContacts, originUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.Uuid,
			&i.OriginUuid,
			&i.RecipientUuid,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readContact = `-- name: ReadContact :one
SELECT uuid, origin_uuid, recipient_uuid, created_at
FROM contacts
WHERE uuid = ?
`

func (q *Queries) ReadContact(ctx context.Context, uuid string) (*Contact, error) {
	row := q.queryRow(ctx, q.readContactStmt, readContact, uuid)
	var i Contact
	err := row.Scan(
		&i.Uuid,
		&i.OriginUuid,
		&i.RecipientUuid,
		&i.CreatedAt,
	)
	return &i, err
}

const searchContacts = `-- name: SearchContacts :many
SELECT contacts.uuid, origin_uuid, recipient_uuid, contacts.created_at, users.uuid, usernm, email, users.created_at, updated_at
FROM contacts 
JOIN users
    ON contacts.recipient_uuid = users.uuid
WHERE users.usernm LIKE ?
    OR users.email LIKE ?
LIMIT 10
`

type SearchContactsParams struct {
	Usernm string
	Email  string
}

type SearchContactsRow struct {
	Uuid          string
	OriginUuid    string
	RecipientUuid string
	CreatedAt     time.Time
	Uuid_2        string
	Usernm        string
	Email         string
	CreatedAt_2   time.Time
	UpdatedAt     sql.NullTime
}

// retrieve all contacts by name and email
func (q *Queries) SearchContacts(ctx context.Context, arg *SearchContactsParams) ([]*SearchContactsRow, error) {
	rows, err := q.query(ctx, q.searchContactsStmt, searchContacts, arg.Usernm, arg.Email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchContactsRow{}
	for rows.Next() {
		var i SearchContactsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.OriginUuid,
			&i.RecipientUuid,
			&i.CreatedAt,
			&i.Uuid_2,
			&i.Usernm,
			&i.Email,
			&i.CreatedAt_2,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
